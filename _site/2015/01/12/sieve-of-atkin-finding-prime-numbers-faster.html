<!DOCTYPE html><html lang="en" manifest="/manifest.appcache"> <!-- Magic. Do not touch! (c) 2011-2016 Maciej A. Czyzewski --><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><meta name="robots" content="index, follow, archive" /><meta name="referrer" content="always" /><title>Sieve of Atkin, finding prime numbers faster - Maciej A. Czyzewski on the Web</title><meta property="og:title" content="Sieve of Atkin, finding prime numbers faster" /><meta name="description" content="It is an optimized version of the ancient sieve of Eratosthenes which does some preliminary work and then marks off multiples of the square of each prime, rather than multiples of the prime itself." /><meta property="og:description" content="It is an optimized version of the ancient sieve of Eratosthenes which does some preliminary work and then marks off multiples of the square of each prime, rather than multiples of the prime itself." /><link rel="canonical" href="http://maciejczyzewski.me/2015/01/12/sieve-of-atkin-finding-prime-numbers-faster.html" /><meta property="og:url" content="http://maciejczyzewski.me/2015/01/12/sieve-of-atkin-finding-prime-numbers-faster.html" /><meta property="og:site_name" content="Maciej A. Czyzewski on the Web" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2015-01-12T05:03:22+01:00" /><link rel="next" href="http://maciejczyzewski.me/2015/02/21/better-debug-notices-in-c-using-macros.html" title="Better debug notices in C, using macros" /><link rel="prev" href="http://maciejczyzewski.me/2015/01/10/monte-carlo-method-calculating-pi.html" title="Monte Carlo method, calculating π" /><meta name="twitter:card" content="summary" /><meta name="twitter:site" content="@_czyzewski" /><meta name="google-site-verification" content="HBawTMww3xGdm4ZIKokBD8_Bx3YudVqrv1PISdhnthE" /> <script type="application/ld+json"> { "@context": "http://schema.org", "@type": "BlogPosting", "headline": "Sieve of Atkin, finding prime numbers faster", "datePublished": "2015-01-12T05:03:22+01:00", "description": "It is an optimized version of the ancient sieve of Eratosthenes which does some preliminary work and then marks off multiples of the square of each prime, rather than multiples of the prime itself.", "logo": "http://maciejczyzewski.me/assets/images/shortcuts/144.png", "url": "http://maciejczyzewski.me/2015/01/12/sieve-of-atkin-finding-prime-numbers-faster.html" } </script><link type="application/atom+xml" rel="alternate" href="http://maciejczyzewski.me/feed.xml" title="Maciej A. Czyzewski on the Web" /><link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:400,300,300italic,400italic,700,700italic,900,900italic" /> <script type="text/x-mathjax-config"> MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}}); </script> <script type="text/javascript" async src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML"></script><link media="all" rel="stylesheet" type="text/css" href="/assets/styles.css" /></head><line></line><header> <a href="/">Maciej A. Czyzewski</a> <a href="/archive">Archive</a> <a href="/research">Research</a> <a href="/projects">Projects</a> <a href="/talks">Talks</a> <a href="/about">About</a></header><main><article><h1>Sieve of Atkin, finding prime numbers faster</h1><hgroup> <span>Posted on <time datetime="">12 January 2015</time></span> <a href="https://twitter.com/share" class="twitter-share-button" data-via="_czyzewski" data-size="large">Tweet</a><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script></hgroup><div><p>It is an optimized version of the ancient <strong>sieve of Eratosthenes</strong> which does some preliminary work and then marks off multiples of the square of each prime, rather than multiples of the prime itself.</p><p>It was created in 2003 by <em>A. O. L. Atkin</em> and <em>Daniel J. Bernstein</em>. References can be found in “<a href="http://www.ams.org/journals/mcom/2004-73-246/S0025-5718-03-01501-1/S0025-5718-03-01501-1.pdf">Prime sieves using binary quadratic forms.</a>”</p><h2 id="complexity">Complexity</h2><p>The page segmented version implemented by the authors has the same $O(N)$ operations but reduces the memory requirement to just that required by the base primes below the square root of the range of $O(N^{1/2} / \log N)$ bits of memory plus a minimal page buffer.</p><h2 id="optimization">Optimization</h2><p>All numbers with a modulo-sixty remainder:</p><ul><li>that is divisible by 2, 3, or 5 are not prime because they are divisible by 2, 3, or 5, respectively.</li><li>1, 13, 17, 29, 37, 41, 49, or 53 have a modulo-four remainder of 1. These numbers are prime iff the number of solutions to $4x^{2} + y^{2} = n$ is odd and the number is not a square of another integer.</li><li>7, 19, 31, or 43 have a modulo-six remainder of 1. These numbers are prime iff the number of solutions to $3x^{2} + y^{2} = n$ is odd and the number is not a square of another integer.</li><li>11, 23, 47, or 59 have a modulo-twelve remainder of 11. These numbers are prime iff the number solutions to $3x^{2} - y^{2} = n$ is odd and the number is not a square of another integer.</li></ul><h2 id="implementation">Implementation</h2><figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c">#!/usr/bin/env python</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">sieveOfAtkin</span><span class="p">(</span><span class="n">end</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span>

  <span class="c"># The array doesn't need to include even numbers</span>
  <span class="n">lng</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">end</span> <span class="o">%</span> <span class="mi">2</span>

  <span class="c"># Create array and assume all numbers in array are prime</span>
  <span class="n">sieve</span> <span class="o">=</span> <span class="p">[</span><span class="bp">True</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">lng</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

  <span class="c"># The transforming is not optimal, and the number of</span>
  <span class="c"># operations involved can be reduced.</span>

  <span class="c"># Only go up to square root of the end</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">end</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">):</span>

    <span class="c"># Skip numbers that aren't marked as prime</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">sieve</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="k">continue</span>

    <span class="c"># Unmark all multiples of i, starting at i**2</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">lng</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">):</span>
      <span class="n">sieve</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

  <span class="c"># Don't forget 2</span>
  <span class="n">primes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span>

  <span class="c"># Gather all the primes into a list, leaving out the composite numbers</span>
  <span class="n">primes</span><span class="o">.</span><span class="n">extend</span><span class="p">([(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lng</span><span class="p">)</span> <span class="k">if</span> <span class="n">sieve</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

  <span class="k">return</span> <span class="n">primes</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
  <span class="n">my</span> <span class="o">=</span> <span class="n">sieveOfAtkin</span><span class="p">(</span><span class="mi">100000</span><span class="p">)</span>

  <span class="c"># Conclusions [2, 3, 5, ... , 99991]</span>
  <span class="k">print</span> <span class="n">my</span></code></pre></figure></div><nav> <a href="/2015/01/10/monte-carlo-method-calculating-pi.html"><p>« previus</p><span>Monte Carlo method, calculating π</span> </a> <a href="/2015/02/21/better-debug-notices-in-c-using-macros.html"><p>next »</p><span>Better debug notices in C, using macros</span> </a></nav></article></main><footer> (c) 2016 <a href="/feed.xml"><svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fill-rule="evenodd" clip-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="1.414"><path d="M12.8 16C12.8 8.978 7.022 3.2 0 3.2V0c8.777 0 16 7.223 16 16h-3.2zM2.194 11.61c1.21 0 2.195.985 2.195 2.196 0 1.21-.985 2.194-2.196 2.194C.984 16 0 15.017 0 13.806c0-1.21.983-2.195 2.194-2.195zM10.606 16h-3.11c0-4.113-3.383-7.497-7.496-7.497v-3.11c5.818 0 10.606 4.79 10.606 10.607z"/></svg></a></footer><script type="text/javascript">(function(e,t,n,r,i,s,o){e["GoogleAnalyticsObject"]=i;e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date;s=t.createElement(n),o=t.getElementsByTagName(n)[0];s.async=1;s.src=r;o.parentNode.insertBefore(s,o)})(window,document,"script","//www.google-analytics.com/analytics.js","ga");ga("create","UA-55884794-1","auto");ga("send","pageview")</script></body></html>
